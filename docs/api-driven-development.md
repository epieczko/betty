# API-Driven Development with Betty

## Overview

This guide explains how to implement API-first development in Betty Framework following Zalando's RESTful API Guidelines and using Modelina for model generation.

---

## Philosophy

**API-Driven Development** means:
1. **Define the API contract first** (OpenAPI/AsyncAPI)
2. **Validate against enterprise guidelines** (Zalando, internal standards)
3. **Generate shared models** from specifications (Modelina)
4. **Implement services** that conform to the contract
5. **Maintain compatibility** across versions

Betty enforces this discipline through **automatic validation hooks** that prevent non-compliant specs from ever being saved.

---

## Zalando RESTful API Guidelines

### Core Principles

**Source**: https://opensource.zalando.com/restful-api-guidelines/

Key requirements Betty will enforce:

1. **API First Principle**
   - Define APIs using OpenAPI before coding
   - Use OpenAPI 3.1 for new APIs
   - Single self-contained YAML file per API
   - Subject to version control

2. **Design Consistency**
   - Follow Zalando naming conventions (snake_case for fields)
   - Use standard HTTP methods correctly
   - Implement proper error responses (RFC 7807 Problem JSON)
   - Include required headers (X-Flow-ID, etc.)

3. **Peer Review**
   - APIs must be reviewed before implementation
   - Use API linter (Zally) for automated checks
   - Document breaking changes

4. **Compatibility**
   - Avoid breaking changes
   - Use API versioning when necessary
   - Implement compatibility validation

---

## Architecture

### Skills for API-Driven Development

```
skills/
├── api.define/              # Create OpenAPI specs
│   ├── skill.yaml
│   ├── api_define.py
│   └── templates/
│       ├── openapi_3.1.yaml.j2
│       └── zalando_compliant.yaml.j2
│
├── api.validate/            # Validate against Zalando guidelines
│   ├── skill.yaml
│   ├── api_validate.py
│   └── validators/
│       ├── zally_client.py      # Zalando's Zally linter integration
│       ├── zalando_rules.py     # Local rule implementations
│       └── custom_rules.py      # Enterprise-specific rules
│
├── api.generate-models/     # Use Modelina for code generation
│   ├── skill.yaml
│   ├── modelina_generate.py
│   └── configs/
│       ├── typescript.json
│       ├── python.json
│       └── java.json
│
├── api.compatibility/       # Check for breaking changes
│   ├── skill.yaml
│   ├── check_compatibility.py
│   └── rules/
│       └── breaking_changes.yaml
│
├── asyncapi.define/         # AsyncAPI for event-driven APIs
│   ├── skill.yaml
│   └── asyncapi_define.py
│
├── hook.define/             # Define validation hooks
│   ├── skill.yaml
│   └── hook_define.py
│
├── command.define/          # Register slash commands
│   ├── skill.yaml
│   └── command_define.py
│
└── agent.define/            # Create agent manifests
    ├── skill.yaml
    └── agent_define.py
```

### Workflows

```
workflows/
├── api_first_development.yaml       # Complete API-first workflow
├── api_validation_suite.yaml        # Comprehensive validation
├── api_version_migration.yaml       # Handle version upgrades
└── shared_model_generation.yaml     # Generate models for all languages
```

### Agents

```
agents/
├── api.designer/            # Design APIs from requirements
├── api.reviewer/            # Review specs for compliance
├── api.migrator/            # Handle API versioning
└── compliance.checker/      # Ensure enterprise standards
```

### Hooks

```
.claude/
└── hooks.yaml               # Generated by hook.define skill
```

---

## Implementation Details

### 1. OpenAPI Spec Structure (Zalando-Compliant)

```yaml
# specs/user-service.openapi.yaml

openapi: 3.1.0

info:
  title: User Service API
  version: 1.0.0
  description: RESTful API for user management
  contact:
    name: Platform Team
    email: platform@company.com
  x-api-id: d0184f38-b98d-11e7-9c56-68f728c1ba70  # Zalando requirement
  x-audience: company-internal                     # Zalando requirement

servers:
  - url: https://api.company.com/users/v1
    description: Production

# Zalando requires all paths to use kebab-case or snake_case
paths:
  /users:
    get:
      summary: List all users
      operationId: listUsers
      tags: [Users]
      parameters:
        - name: limit
          in: query
          schema:
            type: integer
            minimum: 1
            maximum: 100
            default: 20
        - name: offset
          in: query
          schema:
            type: integer
            minimum: 0
            default: 0
      responses:
        '200':
          description: List of users
          headers:
            X-Flow-ID:                            # Zalando requirement
              schema:
                type: string
                format: uuid
          content:
            application/json:
              schema:
                type: object
                properties:
                  users:
                    type: array
                    items:
                      $ref: '#/components/schemas/User'
                  pagination:
                    $ref: '#/components/schemas/Pagination'
        '400':
          $ref: '#/components/responses/BadRequest'
        '500':
          $ref: '#/components/responses/InternalError'

    post:
      summary: Create a new user
      operationId: createUser
      tags: [Users]
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/UserCreate'
      responses:
        '201':
          description: User created successfully
          headers:
            Location:
              schema:
                type: string
                format: uri
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/User'
        '400':
          $ref: '#/components/responses/BadRequest'
        '409':
          $ref: '#/components/responses/Conflict'

  /users/{user_id}:
    parameters:
      - name: user_id
        in: path
        required: true
        schema:
          type: string
          format: uuid

    get:
      summary: Get user by ID
      operationId: getUserById
      tags: [Users]
      responses:
        '200':
          description: User details
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/User'
        '404':
          $ref: '#/components/responses/NotFound'

    put:
      summary: Update user
      operationId: updateUser
      tags: [Users]
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/UserUpdate'
      responses:
        '200':
          description: User updated
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/User'
        '404':
          $ref: '#/components/responses/NotFound'

    delete:
      summary: Delete user
      operationId: deleteUser
      tags: [Users]
      responses:
        '204':
          description: User deleted successfully
        '404':
          $ref: '#/components/responses/NotFound'

components:
  schemas:
    # Zalando requires snake_case for JSON properties
    User:
      type: object
      required: [user_id, email, created_at]
      properties:
        user_id:
          type: string
          format: uuid
          description: Unique user identifier
        email:
          type: string
          format: email
        first_name:
          type: string
          minLength: 1
          maxLength: 100
        last_name:
          type: string
          minLength: 1
          maxLength: 100
        is_active:
          type: boolean
          default: true
        created_at:
          type: string
          format: date-time
        updated_at:
          type: string
          format: date-time

    UserCreate:
      type: object
      required: [email]
      properties:
        email:
          type: string
          format: email
        first_name:
          type: string
        last_name:
          type: string

    UserUpdate:
      type: object
      properties:
        first_name:
          type: string
        last_name:
          type: string
        is_active:
          type: boolean

    Pagination:
      type: object
      required: [limit, offset, total]
      properties:
        limit:
          type: integer
        offset:
          type: integer
        total:
          type: integer

    # Zalando requires RFC 7807 Problem JSON for errors
    Problem:
      type: object
      required: [type, title, status]
      properties:
        type:
          type: string
          format: uri
          description: URI reference identifying the problem type
        title:
          type: string
          description: Short, human-readable summary
        status:
          type: integer
          description: HTTP status code
        detail:
          type: string
          description: Human-readable explanation
        instance:
          type: string
          format: uri
          description: URI reference identifying the specific occurrence

  responses:
    BadRequest:
      description: Bad request
      content:
        application/problem+json:                # Zalando requirement
          schema:
            $ref: '#/components/schemas/Problem'

    NotFound:
      description: Resource not found
      content:
        application/problem+json:
          schema:
            $ref: '#/components/schemas/Problem'

    Conflict:
      description: Conflict (e.g., duplicate email)
      content:
        application/problem+json:
          schema:
            $ref: '#/components/schemas/Problem'

    InternalError:
      description: Internal server error
      content:
        application/problem+json:
          schema:
            $ref: '#/components/schemas/Problem'

# Zalando requires security schemes
securitySchemes:
  bearerAuth:
    type: http
    scheme: bearer
    bearerFormat: JWT

security:
  - bearerAuth: []
```

### 2. AsyncAPI Spec Structure

```yaml
# specs/user-events.asyncapi.yaml

asyncapi: 3.0.0

info:
  title: User Events API
  version: 1.0.0
  description: Event-driven user lifecycle notifications

servers:
  production:
    host: kafka.company.com:9092
    protocol: kafka
    description: Production Kafka cluster

channels:
  user.created:
    address: user.created.v1
    messages:
      UserCreated:
        $ref: '#/components/messages/UserCreated'

  user.updated:
    address: user.updated.v1
    messages:
      UserUpdated:
        $ref: '#/components/messages/UserUpdated'

  user.deleted:
    address: user.deleted.v1
    messages:
      UserDeleted:
        $ref: '#/components/messages/UserDeleted'

operations:
  publishUserCreated:
    action: send
    channel:
      $ref: '#/channels/user.created'

  subscribeUserCreated:
    action: receive
    channel:
      $ref: '#/channels/user.created'

components:
  messages:
    UserCreated:
      name: UserCreated
      title: User Created Event
      contentType: application/json
      payload:
        $ref: '#/components/schemas/UserCreatedPayload'

    UserUpdated:
      name: UserUpdated
      title: User Updated Event
      contentType: application/json
      payload:
        $ref: '#/components/schemas/UserUpdatedPayload'

    UserDeleted:
      name: UserDeleted
      title: User Deleted Event
      contentType: application/json
      payload:
        $ref: '#/components/schemas/UserDeletedPayload'

  schemas:
    UserCreatedPayload:
      type: object
      required: [event_id, user_id, occurred_at]
      properties:
        event_id:
          type: string
          format: uuid
        user_id:
          type: string
          format: uuid
        email:
          type: string
          format: email
        occurred_at:
          type: string
          format: date-time

    UserUpdatedPayload:
      type: object
      required: [event_id, user_id, occurred_at, changes]
      properties:
        event_id:
          type: string
          format: uuid
        user_id:
          type: string
          format: uuid
        changes:
          type: object
        occurred_at:
          type: string
          format: date-time

    UserDeletedPayload:
      type: object
      required: [event_id, user_id, occurred_at]
      properties:
        event_id:
          type: string
          format: uuid
        user_id:
          type: string
          format: uuid
        occurred_at:
          type: string
          format: date-time
```

### 3. Shared Models via Modelina

Betty uses [Modelina](https://www.asyncapi.com/tools/modelina) to generate type-safe models from OpenAPI and AsyncAPI specs.

**TypeScript Models** (generated from `user-service.openapi.yaml`):
```typescript
// src/models/user-service/User.ts
export interface User {
  user_id: string;        // UUID format
  email: string;          // Email format
  first_name?: string;
  last_name?: string;
  is_active: boolean;
  created_at: string;     // ISO 8601 datetime
  updated_at?: string;    // ISO 8601 datetime
}

// src/models/user-service/UserCreate.ts
export interface UserCreate {
  email: string;
  first_name?: string;
  last_name?: string;
}

// src/models/user-service/Pagination.ts
export interface Pagination {
  limit: number;
  offset: number;
  total: number;
}

// src/models/user-service/Problem.ts
export interface Problem {
  type: string;           // URI
  title: string;
  status: number;
  detail?: string;
  instance?: string;      // URI
}
```

**Python Models** (generated from same spec):
```python
# src/models/user_service/user.py
from dataclasses import dataclass
from datetime import datetime
from typing import Optional
from uuid import UUID

@dataclass
class User:
    user_id: UUID
    email: str
    created_at: datetime
    first_name: Optional[str] = None
    last_name: Optional[str] = None
    is_active: bool = True
    updated_at: Optional[datetime] = None

@dataclass
class UserCreate:
    email: str
    first_name: Optional[str] = None
    last_name: Optional[str] = None

@dataclass
class Pagination:
    limit: int
    offset: int
    total: int
```

**Benefits of Shared Models**:
- ✅ Single source of truth (the OpenAPI spec)
- ✅ Type safety across frontend and backend
- ✅ Automatic synchronization when spec changes
- ✅ Reduced errors from manual type definitions
- ✅ IDE autocomplete and type checking

---

## Validation Rules (Zalando Guidelines)

Betty's `api.validate` skill checks these rules:

### Required Fields
- ✅ `info.x-api-id` - Unique API identifier (UUID)
- ✅ `info.x-audience` - Target audience (component-internal, company-internal, etc.)
- ✅ `info.contact` - API owner contact information

### Naming Conventions
- ✅ Paths use kebab-case or snake_case
- ✅ JSON properties use snake_case
- ✅ Query parameters use snake_case
- ✅ Headers use standard casing (X-Flow-ID, etc.)

### HTTP Methods
- ✅ GET for retrieval (idempotent, safe)
- ✅ POST for creation (non-idempotent)
- ✅ PUT for full updates (idempotent)
- ✅ PATCH for partial updates (non-idempotent)
- ✅ DELETE for deletion (idempotent)

### Response Codes
- ✅ 200 for successful GET/PUT/PATCH
- ✅ 201 for successful POST (with Location header)
- ✅ 204 for successful DELETE
- ✅ 400 for bad request
- ✅ 404 for not found
- ✅ 409 for conflict
- ✅ 500 for internal error

### Error Handling
- ✅ Use RFC 7807 Problem JSON for errors
- ✅ Content-Type: `application/problem+json`
- ✅ Include `type`, `title`, `status` fields

### Headers
- ✅ X-Flow-ID for request tracing (UUID)
- ✅ Location for 201 Created responses
- ✅ Content-Type for all responses

### Compatibility
- ✅ No breaking changes in minor versions
- ✅ Additive changes only (new fields optional)
- ✅ Deprecation warnings before removal

---

## Workflow: API-First Development

```yaml
# workflows/api_first_development.yaml

name: api_first_development
version: 1.0.0
description: "Complete API-first development workflow following Zalando guidelines"

inputs:
  service_name: string
  spec_type: openapi|asyncapi
  target_languages: list[string]  # e.g., [typescript, python, java]
  guidelines: string              # e.g., zalando, google, internal

steps:
  # Step 1: Create the specification from template
  - skill: api.define
    args:
      - "{service_name}"
      - "{spec_type}"
      - "--template=zalando"
    output: spec_path
    description: "Create API specification from Zalando-compliant template"

  # Step 2: Validate against Zalando guidelines
  # (Also runs automatically via hook on file edit)
  - skill: api.validate
    args:
      - "{spec_path}"
      - "{guidelines}"
    output: validation_report
    description: "Validate spec against enterprise guidelines"
    required: true

  # Step 3: Generate models for each target language
  - skill: api.generate-models
    args:
      - "{spec_path}"
      - "typescript"
      - "--output=src/models/{service_name}"
    output: ts_models_path
    description: "Generate TypeScript models via Modelina"
    when: "'typescript' in target_languages"

  - skill: api.generate-models
    args:
      - "{spec_path}"
      - "python"
      - "--output=src/models/{service_name}"
    output: py_models_path
    description: "Generate Python models via Modelina"
    when: "'python' in target_languages"

  - skill: api.generate-models
    args:
      - "{spec_path}"
      - "java"
      - "--output=src/main/java/models/{service_name}"
    output: java_models_path
    description: "Generate Java models via Modelina"
    when: "'java' in target_languages"

  # Step 4: Verify generated models compile
  - skill: code.verify
    args:
      - "{ts_models_path}"
      - "typescript"
    description: "Verify TypeScript models compile"
    when: "'typescript' in target_languages"

  - skill: code.verify
    args:
      - "{py_models_path}"
      - "python"
    description: "Verify Python models pass type checking"
    when: "'python' in target_languages"

  # Step 5: Check for breaking changes (if updating existing API)
  - skill: api.compatibility
    args:
      - "specs/{service_name}.{spec_type}.yaml"  # old version
      - "{spec_path}"                             # new version
    output: compatibility_report
    description: "Check for breaking API changes"
    when: "file_exists('specs/{service_name}.{spec_type}.yaml')"
    blocking: true  # Fail workflow if breaking changes detected

  # Step 6: Generate API documentation
  - skill: api.generate-docs
    args:
      - "{spec_path}"
      - "--format=markdown"
      - "--output=docs/api/{service_name}.md"
    output: docs_path
    description: "Generate API documentation"

  # Step 7: Publish to registry
  - skill: api.publish
    args:
      - "{spec_path}"
      - "{service_name}"
      - "--models={ts_models_path},{py_models_path}"
      - "--docs={docs_path}"
    output: registry_entry
    description: "Publish spec, models, and docs to Betty registry"

  # Step 8: Log completion
  - skill: audit.log
    args:
      - "api_first_development"
      - "{service_name}"
      - "{registry_entry}"
    description: "Log workflow completion for audit trail"

audit:
  log_to: /registry/workflow_history.json
  include:
    - All input parameters
    - Validation results
    - Compatibility report (if ran)
    - Generated artifacts
    - Execution time per step

on_failure:
  cleanup:
    - Remove partial spec if validation failed
    - Remove partial models if generation failed
  notify:
    - skill: audit.log
      args: ["api_first_development_failed", "{service_name}", "{error}"]
```

---

## Hooks: Automatic Validation

```yaml
# .claude/hooks.yaml (generated by hook.define skill)

hooks:
  # Validate OpenAPI specs on every edit
  on_file_edit:
    - name: validate-openapi-zalando
      description: "Validate OpenAPI specs against Zalando guidelines"
      when:
        pattern: "*.openapi.yaml"
      command: "python betty/skills/api.validate/api_validate.py {file_path} zalando"
      blocking: true
      timeout: 10000  # 10 seconds
      on_failure:
        action: show_errors
        message: "OpenAPI spec violates Zalando guidelines. See errors above."

    - name: validate-asyncapi
      description: "Validate AsyncAPI specs"
      when:
        pattern: "*.asyncapi.yaml"
      command: "python betty/skills/asyncapi.validate/asyncapi_validate.py {file_path}"
      blocking: true
      timeout: 10000

  # Regenerate models when specs change
  on_file_save:
    - name: regenerate-models-on-spec-change
      description: "Auto-regenerate models when API specs are saved"
      when:
        pattern: "specs/*.openapi.yaml"
      command: "python betty/skills/api.generate-models/auto_generate.py {file_path}"
      blocking: false  # Run async, don't block save
      async: true

  # Check compatibility before commit
  on_commit:
    - name: check-breaking-changes
      description: "Prevent commits with breaking API changes"
      when:
        changed_files: "specs/**/*.yaml"
      command: "python betty/skills/api.compatibility/check_breaking_changes.py {file_path}"
      blocking: true
      on_failure:
        action: abort_commit
        message: "Breaking API changes detected. Use major version bump."

  # Run full validation suite before push
  on_push:
    - name: full-api-validation-suite
      description: "Run complete API validation before pushing"
      when:
        changed_files: "specs/**"
      command: "python betty/skills/workflow.compose/workflow_compose.py workflows/api_validation_suite.yaml"
      blocking: true
      timeout: 300000  # 5 minutes
```

---

## Usage Examples

### Example 1: Design a New API

```bash
# User runs command
/api-design user-service

# Betty executes:
# 1. api.designer agent starts
# 2. Loads Zalando template
# 3. Creates specs/user-service.openapi.yaml
# 4. Hook validates automatically (BLOCKS if invalid)
# 5. Generates TypeScript models
# 6. Generates Python models
# 7. Verifies models compile
# 8. Publishes to registry

# Output:
✓ Created specs/user-service.openapi.yaml
✓ Validated against Zalando guidelines (PASSED)
✓ Generated TypeScript models → src/models/user-service/
✓ Generated Python models → src/models/user-service/
✓ All models compile successfully
✓ Published to registry

# Files created:
specs/user-service.openapi.yaml
src/models/user-service/User.ts
src/models/user-service/UserCreate.ts
src/models/user-service/Pagination.ts
src/models/user-service/user.py
docs/api/user-service.md
```

### Example 2: Validate Existing Spec

```bash
# Direct skill invocation
python betty/skills/api.validate/api_validate.py specs/user-service.openapi.yaml zalando

# Or via command
/api-validate specs/user-service.openapi.yaml

# Output:
{
  "status": "success",
  "data": {
    "valid": true,
    "errors": [],
    "warnings": [
      "Consider adding rate limit documentation"
    ],
    "guideline_version": "zalando-1.0",
    "spec_version": "3.1.0"
  }
}
```

### Example 3: Automatic Validation on Edit

```bash
# User edits specs/user-service.openapi.yaml
# Hook runs automatically:

→ Running validate-openapi-zalando...

✗ Validation failed:
  - Missing required field: info.x-api-id
  - Property 'userId' should use snake_case (user_id)
  - Response 400 must use application/problem+json

❌ File edit blocked until errors are fixed
```

### Example 4: Generate Models in Multiple Languages

```bash
# Run workflow
python betty/skills/workflow.compose/workflow_compose.py \
  workflows/api_first_development.yaml \
  --service-name=user-service \
  --spec-type=openapi \
  --target-languages=typescript,python,java

# Generates:
src/models/user-service/User.ts
src/models/user-service/User.py
src/main/java/models/userservice/User.java

# All from the same OpenAPI spec!
```

---

## Benefits

### For Developers
- ✅ **Immediate feedback**: Validation happens on every edit, not at commit time
- ✅ **Consistent APIs**: Zalando guidelines enforced automatically
- ✅ **Type safety**: Shared models between frontend/backend
- ✅ **Less boilerplate**: Models generated, not hand-written
- ✅ **Confidence**: Breaking changes caught before merge

### For Teams
- ✅ **Contract-first**: API contracts defined before implementation
- ✅ **Parallel development**: Frontend/backend can work independently
- ✅ **Documentation**: Always up-to-date, generated from specs
- ✅ **Versioning**: Breaking changes tracked and managed
- ✅ **Onboarding**: New developers see the contract first

### For Organizations
- ✅ **Compliance**: Zalando guidelines enforced, not suggested
- ✅ **Audit trail**: Every API change logged
- ✅ **Consistency**: All APIs follow same patterns
- ✅ **Quality**: Automated validation reduces errors
- ✅ **Maintainability**: Specs are living documentation

---

## Next Steps

1. **Implement Phase 1**: Create `hook.define` and `api.validate` skills
2. **Integrate Zally**: Set up Zalando's Zally linter
3. **Integrate Modelina**: Set up code generation
4. **Create Templates**: Build Zalando-compliant OpenAPI templates
5. **Document Workflow**: Create team runbook for API-first development

---

## References

- [Zalando RESTful API Guidelines](https://opensource.zalando.com/restful-api-guidelines/)
- [Zally API Linter](https://github.com/zalando/zally)
- [Modelina Code Generator](https://www.asyncapi.com/tools/modelina)
- [OpenAPI 3.1 Specification](https://spec.openapis.org/oas/v3.1.0)
- [AsyncAPI 3.0 Specification](https://www.asyncapi.com/docs/reference/specification/v3.0.0)
- [RFC 7807 Problem Details](https://datatracker.ietf.org/doc/html/rfc7807)
- [Betty Architecture](./betty-architecture.md)
- [Betty Skills Framework](./skills-framework.md)
